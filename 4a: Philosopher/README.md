# <p align="center"> ![image](https://github.com/ChrstphrChevalier/42Cursus/assets/146819291/bdca9a2b-b0b0-477f-8e96-9cd35173b6be) </p>

##### <p align="center"> *As part of my time at School 42, I worked on the Philosophers project, an emblematic exercise based on the classic problem of philosopher-eaters. This project allowed me to explore in depth the concepts of concurrency, synchronization and thread management in C.* </p>

##### <p align="center"> *The key concepts I learned during this project include the creation and management of threads. I learned how to use the pthread library to create threads, launch them, and manage them throughout their lifecycle. This experience gave me a practical understanding of concurrent programming and efficient use of system resources.* </p>

##### <p align="center"> *A crucial aspect of the Philosophers project was synchronization management. I learned how to use mutexes to avoid race conditions and ensure that shared resources (like forks) were used safely and consistently. I also used semaphores to manage access to limited resources, ensuring that no philosopher was left stuck indefinitely (avoiding starvation).* </p>

##### <p align="center"> *In addition, I acquired skills in time management and deadlines. The project required the implementation of precise timers to simulate the actions of philosophers (eating, thinking, sleeping) and to check the end-of-life conditions of the threads. This fine time management allowed me to strengthen my skills in real-time programming and deadline management.* </p>

##### <p align="center"> *The project also taught me the importance of code design and architecture. I had to structure my program in a modular way to separate different responsibilities, such as thread management, synchronization, and simulation logic. This approach helped me write code that was cleaner, more maintainable, and easier to debug.* </p>

##### <p align="center"> *Additionally, I developed skills in debugging and performance analysis. Working with threads and synchronization mechanisms confronted me with subtle and difficult-to-reproduce bugs, which I learned to identify and fix using debugging and profiling tools. I also optimized my code to improve performance and reduce unnecessary wait times.* </p>

##### <p align="center"> *The Philosophers project also made me aware of the importance of rigorous testing. I created a series of tests to verify that my program worked correctly in various scenarios, including edge cases and stressful situations. These tests helped me ensure the robustness and reliability of my program.* </p>

##### <p align="center"> *In summary, the Philosophers project allowed me to develop a deep understanding of concurrent programming, synchronization and thread management. The skills learned during this project are essential for any developer working with multithreaded or real-time systems, and they continue to serve me well in my subsequent projects, where I am often required to design competitive and high-performance systems.* </p>

# <p align="center">     </p>

# <p align="center"> - Result - </p>

# <p align="center"> ![image](https://github.com/ChrstphrChevalier/42Cursus/assets/146819291/c059fc28-606b-41d9-82ca-07838248a68c) </p>

# <p align="center"> - #*next* - </p>
